小多想在美化一下自己的庄园。他的庄园毗邻一条小河，他希望在河边种一排树，共 M 棵。小多采购了 N 个品种的树，每个品种的数量是 Ai (树的总数量恰好为 M)。但是他希望任意两棵相邻的树不是同一品种的。小多请你帮忙设计一种满足要求的种树方案。

输入描述:
第一行包含一个正整数 N，表示树的品种数量。
第二行包含 N 个正整数，第 i (1 <= i <= N) 个数表示第 i 个品种的树的数量。
数据范围：
1 <= N <= 1000
1 <= M <= 2000

输出描述:
输出一行，包含 M 个正整数，分别表示第 i 棵树的品种编号 (品种编号从1到 N)。若存在多种可行方案，则输出字典序最小的方案。若不存在满足条件的方案，则输出"-"。

输入例子1:
3
4 2 1

输出例子1:
1 2 1 2 1 3 1

import java.util.*;

public class Main {
    static List<String> ans;
    static int kinds;//树的种类
    static int[] trees;
    static int m;//坑
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        kinds = sc.nextInt();
        trees = new int[kinds + 1];
        m = 0;
        for(int i = 1; i <= kinds; i++){
            trees[i] = sc.nextInt();
            m += trees[i];
        }
        ans = new ArrayList<>();
        if(dfs(0)){
            System.out.println(String.join(" ",ans));
        }
        else
            System.out.println("-");
    }

    static boolean dfs(int idx){
        //如果某种树的数量大于(left + 1)/2，则一定会有两个相邻位置是同一种树
        if(!check(m - idx))
            return false;
        if(idx == m){
            return true;
        }
        else{
            for(int i = 1; i <= kinds; i++){
                if(idx == 0 || (trees[i] != 0 && i != Integer.valueOf(ans.get(ans.size() - 1)))){
                    trees[i]--;
                    ans.add(i + "");
                    if(dfs(idx + 1))
                        return true;
                    ans.remove(ans.size() - 1);
                    trees[i]++;
                }
            }
        }
        return false;
    }

    public static boolean check(int left){
        for(int i = 1; i <= kinds; i++){
            if(trees[i] > (left+1)/2 )
                return false;
        }
        return true;
    }
}
